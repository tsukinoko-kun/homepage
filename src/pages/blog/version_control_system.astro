---
import Layout from "../../layouts/Layout.astro";
import Mermaid from "../../components/Mermaid.astro";
---

<Layout title="Version Control System" desc="Git und co." class="blog">
    <h1 class="text-5xl font-semibold tracking-tight surround-h1">
        Version Control System
    </h1>
    <p>Git und co.</p>

    <h2>Der Ursprung von Git</h2>
    <p>
        Das Linux-Kernel-Projekt, eines der größten Open-Source-Projekte der
        Welt, nutzte bis 2005 ein proprietäres, verteiltes
        Versionskontrollsystem (VCS) namens <a href="https://www.bitkeeper.org/"
            >BitKeeper</a
        >. Die Lizenz zur kostenlosen Nutzung wurde dem Kernel-Team jedoch
        entzogen. Dies schuf ein akutes Problem: Man benötigte ein neues VCS,
        das die extremen Anforderungen des Projekts erfüllen konnte:
    </p>
    <ul>
        <li>
            Verteilt (Distributed): Tausende Entwickler weltweit mussten
            effizient zusammenarbeiten können.
        </li>
        <li>
            Performant: Operationen wie Branching und Merging mussten extrem
            schnell sein.
        </li>
        <li>
            Sicher: Die Integrität des riesigen Code-Repositorys musste
            jederzeit gewährleistet sein.
        </li>
    </ul>
    <p>
        Da keine existierende Lösung diese Kriterien erfüllte, nahm Linus
        Torvalds, der Initiator von Linux, die Sache selbst in die Hand.
    </p>
    <p>
        Innerhalb weniger Wochen entwickelte Linus Torvalds den Kern von Git.
        Seine Ziele waren nicht, ein benutzerfreundliches System zu schaffen,
        sondern ein extrem schnelles und robustes Fundament. Die erste Version
        war minimalistisch und bestand aus einfachen Kommandozeilen-Tools, die
        aber bereits die Kernprinzipien von Git umsetzten.
    </p>
    <p>
        Linus Torvalds' Hauptinteresse galt weiterhin dem Linux-Kernel. Nachdem
        er das Fundament von Git gelegt hatte, übergab er das Projekt im Juli
        2005 an Junio C Hamano, einen der frühen und wichtigsten Beitragenden.
    </p>
    <p>Unter Hamanos Leitung wurde Git zu dem, was wir heute kennen.</p>
    <p>
        Der eigentliche Durchbruch von Git in der breiten Masse kam mit dem
        Aufstieg von Code-Hosting-Plattformen, auch "Forges" genannt.
    </p>
    <p>
        Diese Plattformen erweitern die reine Versionskontrolle um entscheidende
        Kollaborations-Features:
    </p>
    <ul>
        <li>
            GitHub (2008): Machte Git durch eine grafische Oberfläche zugänglich
            und popularisierte den "Pull Request"-Workflow, der heute Standard
            für Open-Source-Kollaboration ist.
        </li>
        <li>
            GitLab (2011): Positionierte sich als "complete DevOps platform" und
            bietet neben Code-Hosting auch integrierte CI/CD-Pipelines,
            Issue-Tracking und mehr. GitLab ist sowohl als SaaS als auch als
            Self-Hosted-Lösung sehr populär.
        </li>
        <li>
            Gitea, Bitbucket etc.: Es gibt viele weitere Player. Gitea ist eine
            beliebte, leichtgewichtige Self-Hosted-Alternative zu GitHub.
        </li>
    </ul>

    <h2>Mehr als nur Git</h2>
    <p>Sowohl vor, als auch nach Git, gibt es viele weitere VCSs.</p>
    <ul>
        <li>
            <a href="https://subversion.apache.org/">Subversion</a> (SVN, 2000):
            Zentralisiertes VCS von der Apache Software Foundation, das Verzeichnisse
            und Dateien versioniert und als Nachfolger von CVS entwickelt wurde.
            Wird kaum noch verwendet.
        </li>
        <li>
            <a href="https://www.perforce.com/products/helix-core"
                >Perforce Helix Core</a
            > (1995): Kommerzielles, zentralisiertes VCS, das sich durch hohe Performance
            in großen Mono-Repositories und feingranulare Zugriffs­kontrolle auszeichnet.
            Wird viel für Videospiele verwendet.
        </li>
        <li>
            <a href="https://www.mercurial-scm.org/">Mercurial</a> (2005): Verteilt
            arbeitendes VCS in Python, legt Wert auf Einfachheit, Geschwindigkeit
            und Konsistenz der Kommandozeilenoberfläche. Wird außer bei Meta kaum
            noch verwendet.
        </li>
        <li>
            <a href="https://fossil-scm.org/">Fossil</a> (2006): In C implementiertes,
            integriertes System von D. Richard Hipp (SQLite-Autor) mit eingebautem
            Bug-Tracker, Wiki und Web-Oberfläche in einem einzigen Programm. Das
            gesamte Repository ist in einer SQLite-Datenbank gespeichert. Wird außer
            für SQLite, kaum verwendet.
        </li>
        <li>
            <a href="https://pijul.org/">Pijul</a> (2014): Experimentelles, verteiltes
            VCS in Rust, basiert auf der Theorie der Patches und zielt auf einfachere
            Merges und bessere formale Korrektheit ab. Wird kaum verwendet.
        </li>
        <li>
            <a href="https://jj-vcs.github.io/jj/latest/">Jujutsu</a> (2021):Verteiltes,
            Git-kompatibles VCS in Rust, initiiert von Martin von Zweigbergk (Google),
            mit Fokus auf intuitivere Historienbearbeitung und erweiterte Merge-Strategien.
            Wird aktiv in einigen Git Repositories verwendet. Genaue Nutzerzahlen
            lassen sich aber aufgrund der Git-Kompatibilität schwer bestimmen.
        </li>
    </ul>

    <h2>Änderungen</h2>
    <p>
        Viele glauben, dass Git nur die Änderungen von einem Commit zum nächsten
        speichert. Das macht fast kein VCS, weil es ineffizient ist.
    </p>
    <p>
        Die meisten VCSs speichern Snapshots. Das ist eine Liste von allen
        Dateien, die in einem Commit enthalten sind. Eine Datei in Git hat einen
        Namen (Pfad), eine executable Flag und einen Inhalt. Es werden also in
        jedem Commit alle Dateien gespeichert, nicht nur die, die sich verändert
        haben. Zudem ist es egal wie viel sich an einer Datei geändert hat, sie
        wird vollständig, neu gespeichert.
    </p>
    <p>
        Dabei gibt es aber eine wichtige Optimierung: Es kommt ständig vor, dass
        ein Dateiinhalt mehrmals auftritt. Wenn sich eine Datei durch einen
        Commit nicht ändert, muss auch nicht der komplette Inhalt ein zweites
        mal gespeichert werden. Genauso, wenn zwei Dateien denselben Inhalt
        haben, muss dieser nur einmal gespeichert werden.
    </p>
    <p>
        Das lässt sich mit PNPM vergleichen, dass NPM-Pakete zetral ablegt und
        per Symlink im <code>node_modules</code>-Verzeichnis referenziert,
        anstatt sie dorthin zu kopieren, (unter anderem) um Speicherplatz zu
        sparen.
    </p>
    <Mermaid
        class=""
        diagram={`erDiagram
    COMMIT }o--o{ FILE : ""
    FILE }o--|| CONTENT : ""
    `}
    />

    <h2>Merge</h2>
    <p>
        Wenn zwei Commits zusammengeführt werden, muss das VCS einen
        Three-Way-Merge durchführen. Dabei wird die Commit-Historie als DAC
        (Directed Acyclic Graph) betrachtet. In einem DAC ist es einfach, den
        LCA (Lowest Common Ancestor) zu finden. Das ist der Commit, der ein
        Parent der beiden zusammenzuführenden Commits ist, der am tiefsten im
        DAC liegt, also am weitesten vom initial-Commit entfernt ist.
    </p>
    <p>
        Das klingt kompliziert. Grafisch dargestellt sieht es aber ganz einfach
        aus:
    </p>
    <Mermaid
        diagram={`gitGraph
    commit id: "initial commit"
    commit id: "LCA"
    branch feature-1
    checkout main
    commit id: "A"
    checkout feature-1
    commit id: "B"
    checkout main
    commit id: "C"
    merge feature-1 id: "B+C merge"
   `}
    />
    <p>
        Wenn die Commits B und C zusammengeführt werden sollen, benötigt es eine
        gemeinsame Basis, mit der die Änderungen der beiden Commits miteinander
        verglichen werden können. Diese gemeinsame Basis ist der neueste Commit,
        der ein Parent von B und C ist (der LCA).
    </p>
</Layout>
