---
import Layout from "../../layouts/Layout.astro";
import Mermaid from "../../components/Mermaid.astro";
import { Code } from "astro:components";
import "../../styles/blog.scss";
---

<Layout
    title="Shipping Go software with Goreleaser and … Zig?"
    desc="Zig is actually the best C toolchain for CGO-heavy Go builds. Here's how I use it to ship my Go software with Goreleaser."
    class="blog"
>
    <section>
        <h1>Shipping Go software with Goreleaser and ... Zig?</h1>

        <p>
            The Go community is divided on using C libraries versus Go rewrites.
            Using C in Go is straightforward (on the surface) but it creates
            problems along the way.
        </p>
        <p>
            I've been shipping my version control system, <a
                target="_blank"
                href="https://pogo-vcs.com">Pogo</a
            >, starting with pure Go for everything, including <a
                target="_blank"
                href="https://pkg.go.dev/github.com/klauspost/compress/zstd"
                >Zstd</a
            > for compression.
        </p>
        <p>
            It worked without problems. But I wanted the speed and maturity of C
            libraries where it mattered. Zstd was originally written at Facebook
            in C. I would feel better using this mature code over a Go rewrite –
            no shame on the Go rewrite.
        </p>

        <h2>Using C in Go</h2>
        <p>
            It's straightforward to call C from Go. You write a special comment
            above an
            <code>import "C"</code> line. Inside that comment, you include headers
            or small C snippets. Go then asks your system C toolchain to compile
            and link that code into your Go binary. You can pass flags with
            <code>#cgo CFLAGS</code> and <code>#cgo LDFLAGS</code>. You can also
            toggle C dependencies using build tags like <code
                >//go:build cgo</code
            >.
        </p>

        <Code
            lang="go"
            code={'/*\n#cgo CFLAGS: -O3\n#include <stdlib.h>\n\nint add(int a, int b) { return a + b; }\n*/\nimport "C"\n\nfunc Add(a, b int) int {\n\treturn int(C.add(C.int(a), C.int(b)))\n}'}
        />

        <p>
            Conditional builds are handy. You can keep a pure Go fallback and a
            C-backed version:
        </p>

        <Code
            lang="go"
            code={"//go:build cgo\n\npackage compression\n\n// C-backed version here"}
        />

        <Code
            lang="go"
            code={"//go:build !cgo\n\npackage compression\n\n// Pure Go fallback here"}
        />

        <p>
            That's how I did it. I used the C libraries when a C compiler was
            available and added a pure Go fallback when it wasn't.
        </p>

        <h2>Go cross compilation, the nice part</h2>
        <p>
            Go makes it easy to build for other platforms. You pick a target by
            setting
            <code>GOOS</code> and <code>GOARCH</code>. The toolchain builds your
            code for that target. Simple.
        </p>

        <Code
            lang="bash"
            code={"GOOS=darwin GOARCH=arm64 go build -o bin/pogo"}
        />

        <p>
            This works great for pure Go. It's fast, reproducible, and portable.
        </p>

        <h2>Enter Goreleaser</h2>
        <p>
            <a target="_blank" href="https://goreleaser.com/">Goreleaser</a> is a
            great tool for building and publishing Go binaries to package managers
            like Homebrew, npm, and winget. It leans on cross compilation to produce
            a matrix of builds. That means that you run Goreleaser once and it builds
            for all your target platforms at once. That's perfect for pure Go. But
            there's a catch with C code: cross compilation won't work.
        </p>

        <p>
            That's reasonable. When you build C, you need a compiler and system
            headers for the target platform. When you run the cross compilation
            on a Linux runner, the C compiler doesn't know about Windows or
            macOS. Cross compilation with CGO is not trivial and requires a
            cross C toolchain and target headers; by default it fails. You
            should run your builds on the target platforms, that's way simpler.
        </p>

        <h2>Split and merge to avoid cross compiling the hard parts</h2>
        <p>
            I found a helpful post:
            <a
                target="_blank"
                href="https://carlosbecker.com/posts/goreleaser-split-merge/"
            >
                Split and Merge with Goreleaser Pro
            </a>
            . The idea is elegant:
        </p>

        <ul>
            <li>
                Build each target on its native runner (no cross compilation
                toolchains).
            </li>
            <li>Upload the artifacts.</li>
            <li>Merge everything into one release.</li>
        </ul>

        <Mermaid
            diagram={`flowchart LR
        A[Git tag push] --> B[Linux runner]
        A --> C[macOS runner]
        A --> D[Windows runner]
        B -->|native build| E[dist/linux artifacts]
        C -->|native build| F[dist/macos artifacts]
        D -->|native build| G[dist/windows artifacts]
        E --> H[Merge job]
        F --> H
        G --> H
        H --> I[Single release with all targets]
      `}
        />

        <p>In CI, it looks like this:</p>
        <Code
            lang="bash"
            code={"# Per-platform job\ngoreleaser release --clean --split --skip-publish\n\n# Merge job (after collecting all artifacts)\ngoreleaser continue --merge"}
        />

        <h2>New problem: Windows</h2>
        <p>
            Linux ARM and macOS ARM were okay thanks to native runners. Windows
            ARM was painful. The available runner story wasn't smooth, and cross
            compilation kept picking the wrong <code>gcc</code>/<code
                >clang</code
            >.
        </p>

        <h3>Zig to the rescue</h3>
        <p>
            Zig ships a great C toolchain with cross compilation built in. I
            pointed Go at Zig's compilers and set a target triple. That made the
            C parts compile for Windows ARM reliably.
        </p>

        <Code
            lang="bash"
            code={'# Cross-compile Windows ARM CGO with Zig\nGOOS=windows GOARCH=arm64 CGO_ENABLED=1 \\\nCC="zig cc -target aarch64-windows" \\\nCXX="zig c++ -target aarch64-windows" \\\ngo build -o bin/pogo.exe'}
        />

        <h2>Next problem: libc</h2>
        <p>
            Quick recap: The <a
                target="_blank"
                href="https://www.man7.org/linux/man-pages/man7/libc.7.html"
                >libc</a
            > is a library that is provided by the OS. It translates C function calls
            into system calls. There are multiple libc implementations for different
            OSes. The most common ones are glibc and musl but there are others. Debian
            uses glibc but you could use musl on Debian if you provide the musl libc
            package. That's the whole point, the OS is providing the libc so you
            don't have to. Languages like Go and Zig don't use a libc at all, they
            use the system calls directly, which is similar to statically linking
            a libc.
        </p>

        <p>
            By default, C code links against your OS libc dynamically. Most
            Linux distros use glibc. Alpine uses musl, Android uses Bionic, etc.
            Shipping separate binaries for each libc would explode the matrix.
            Worse, the installers provided by Goreleaser don't let you choose
            binaries by libc at install time. They only support OS and
            architecture.
        </p>

        <p>
            I needed one Linux binary. No runtime libc dependency. The fix:
            static link against musl. Zig makes this easy, even on Ubuntu-based
            runners.
        </p>

        <Code
            lang="bash"
            code={`# Statically link musl libc using Zig\nCGO_ENABLED=1 GOOS=linux GOARCH=amd64 \\\nCC="zig cc -target x86_64-linux-musl" \\\nCXX="zig c++ -target x86_64-linux-musl" \\\ngo build -trimpath \\\n  -ldflags='-s -w -linkmode=external -extldflags "-static"' \\\n  -o bin/pogo`}
        />

        <p>
            Result: a single Linux binary that runs on glibc and musl systems,
            because it doesn't need the host's libc at all. Problem solved.
        </p>

        <p>
            But wait, I still depend on a minimum kernel version/syscalls…
            <br />
            No, that not a problem. You all use modern Linux kernels anyway, right?
            Right?
        </p>

        <h2>Putting it together</h2>
        <ul>
            <li>
                Pure Go? Use cross basic compilation. It's simple and portable.
            </li>
            <li>
                CGO? Prefer native builds per target with split and merge. Use
                runners that match your targets.
            </li>
            <li>
                Missing or flaky runners (like Windows ARM)? Use Zig's cross
                toolchain.
            </li>
            <li>
                Want one Linux binary? Static link against musl with Zig to drop
                the libc runtime dependency.
            </li>
        </ul>

        <p>
            Full example setup:
            <a
                target="_blank"
                href="https://github.com/tsukinoko-kun/goreleaser-cgo"
            >
                github.com/tsukinoko-kun/goreleaser-cgo
            </a>
        </p>

        <p>
            Thanks Goreleaser for the great release flow. And thanks to Zig for
            being a fantastic C toolchain for CGO-heavy builds.
        </p>
    </section>
</Layout>
