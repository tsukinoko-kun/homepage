---
import Layout from "../layouts/Layout.astro";

import AvailabilityCalendar from "../components/AvailabilityCalendar";
import {
    startOfDay,
    endOfDay,
    addMonths,
    eachDayOfInterval,
    format,
    setHours,
    addMinutes,
    isWithinInterval,
    parseISO,
    startOfMonth,
    endOfMonth,
} from "date-fns";
import { fromZonedTime } from "date-fns-tz";
import ICAL from "ical.js";

// Your calendar URIs
const calendarUris = (
    (process.env.CALENDAR_URIS || "").split(",") as string[]
).filter(Boolean);

// Helper function to fetch calendar data
async function fetchCalendarData(uri: string) {
    try {
        // Convert webcal to https
        const httpsUri = uri.replace("webcal://", "https://");
        const response = await fetch(httpsUri);
        const icsData = await response.text();
        return icsData;
    } catch (error) {
        console.error(`Failed to fetch calendar: ${uri}`, error);
        return null;
    }
}

// Parse ICS data and extract events (including recurring instances)
function parseEvents(icsData: string, startRange: Date, endRange: Date) {
    const jcalData = ICAL.parse(icsData);
    const comp = new ICAL.Component(jcalData);

    // Get the timezone components from the calendar
    const vtimezones = comp.getAllSubcomponents("vtimezone");
    const timezones = {};

    vtimezones.forEach((vtimezone) => {
        const tzid = vtimezone.getFirstPropertyValue("tzid");
        if (tzid) {
            timezones[tzid] = new ICAL.Timezone(vtimezone);
            // Don't register globally - it causes conflicts with ICAL.js's built-in handling
        }
    });

    const vevents = comp.getAllSubcomponents("vevent");
    const allEvents = [];

    vevents.forEach((vevent) => {
        const event = new ICAL.Event(vevent);

        if (event.isRecurring()) {
            // For recurring events, expand all instances within our range
            const iterator = event.iterator();
            let next;

            // Check if we need manual timezone handling
            const needsManualTz =
                Object.keys(timezones).length > 0 &&
                event.startDate?.zone?.tzid &&
                event.startDate.zone.tzid !== "floating";

            while ((next = iterator.next())) {
                let instanceStart, instanceEnd;

                if (needsManualTz) {
                    // Manual timezone conversion for calendars with custom timezone definitions
                    const instanceTimeStr = next.toString();
                    instanceStart = fromZonedTime(
                        parseISO(instanceTimeStr),
                        "Europe/Berlin",
                    );
                    const duration =
                        event.endDate.toJSDate().getTime() -
                        event.startDate.toJSDate().getTime();
                    instanceEnd = new Date(instanceStart.getTime() + duration);
                } else {
                    // Use ICAL.js default handling
                    instanceStart = next.toJSDate();
                    const duration =
                        event.endDate.toJSDate().getTime() -
                        event.startDate.toJSDate().getTime();
                    instanceEnd = new Date(instanceStart.getTime() + duration);
                }

                // Only include instances that overlap with our range
                if (instanceEnd >= startRange && instanceStart <= endRange) {
                    allEvents.push({
                        start: instanceStart,
                        end: instanceEnd,
                    });
                }

                // Stop if we've gone past our end range
                if (instanceStart > endRange) {
                    break;
                }
            }
        } else {
            // Single event
            // Check if this is a timezone that ICAL.js might not handle correctly
            const startTzid = event.startDate?.zone?.tzid;
            const endTzid = event.endDate?.zone?.tzid;

            let startDate, endDate;

            // If we have timezone definitions in this calendar and the event uses them,
            // we need to handle the conversion manually because ICAL.js seems to fail
            if (
                Object.keys(timezones).length > 0 &&
                startTzid &&
                startTzid !== "floating"
            ) {
                // The event time is in the specified timezone
                // We need to convert it properly to UTC
                const startTimeStr = event.startDate.toString(); // e.g., "2025-08-20T11:00:00"
                const endTimeStr = event.endDate.toString();

                // Parse as Europe/Berlin time and convert to UTC
                // Since both Europe/Berlin and Europe/Zurich are CET/CEST, we can use Europe/Berlin
                const timezone = "Europe/Berlin";
                startDate = fromZonedTime(parseISO(startTimeStr), timezone);
                endDate = fromZonedTime(parseISO(endTimeStr), timezone);
            } else {
                // Use default ICAL.js conversion
                startDate = event.startDate.toJSDate();
                endDate = event.endDate.toJSDate();
            }

            allEvents.push({
                start: startDate,
                end: endDate,
            });
        }
    });

    return allEvents;
}

// Generate time slots for a day (30-minute intervals)
function generateDaySlots(date: Date) {
    const slots = [];
    // Generate slots from 10:00 to 22:00 in the date's context
    // Since we're working in CET/CEST timezone, these times are already in the right zone
    const dayStart = setHours(startOfDay(date), 10); // 10am
    const dayEnd = setHours(startOfDay(date), 22); // 10pm

    let current = dayStart;
    while (current < dayEnd) {
        slots.push({
            start: current,
            end: addMinutes(current, 30),
        });
        current = addMinutes(current, 30);
    }

    return slots;
}

// Check if a slot overlaps with any busy period
function isSlotAvailable(slot: any, busyPeriods: any[]) {
    return !busyPeriods.some(
        (busy) =>
            // Slot start is within busy period (exclusive of end)
            (slot.start >= busy.start && slot.start < busy.end) ||
            // Slot end is within busy period (exclusive of start)
            (slot.end > busy.start && slot.end <= busy.end) ||
            // Slot completely contains the busy period
            (slot.start <= busy.start && slot.end >= busy.end),
    );
}

// Main logic to generate availability data
const now = new Date();
const threeMonthsLater = endOfMonth(addMonths(now, 3));

// Fetch all calendar data
const allEvents = [];
for (const uri of calendarUris) {
    const icsData = await fetchCalendarData(uri);
    if (icsData) {
        const events = parseEvents(icsData, now, threeMonthsLater);
        allEvents.push(...events);
    }
}

// Filter events within our time range
// An event is relevant if it starts OR ends within our range,
// OR if it spans across our range
const relevantEvents = allEvents.filter((event) => {
    const eventStart = event.start;
    const eventEnd = event.end;

    // Check if event overlaps with our time range in any way
    return (
        // Event starts within range
        (eventStart >= now && eventStart <= threeMonthsLater) ||
        // Event ends within range
        (eventEnd >= now && eventEnd <= threeMonthsLater) ||
        // Event spans the entire range
        (eventStart <= now && eventEnd >= threeMonthsLater)
    );
});

// Generate availability data by month
const availabilityData = {};

// Process each month
let currentMonth = startOfMonth(now);
while (currentMonth <= threeMonthsLater) {
    const monthEnd = endOfMonth(currentMonth);
    const monthKey = format(currentMonth, "yyyy-MM");
    const monthAvailability = {};

    // Process each day in the month
    const days = eachDayOfInterval({
        start: currentMonth,
        end: monthEnd,
    });

    for (const day of days) {
        const dayKey = format(day, "yyyy-MM-dd");
        const daySlots = generateDaySlots(day);

        // Find busy periods for this day
        const dayStart = startOfDay(day);
        const dayEnd = endOfDay(day);
        const dayBusyPeriods = relevantEvents.filter((event) => {
            // Event overlaps with this day if:
            // 1. Event starts before day ends AND event ends after day starts
            return event.start < dayEnd && event.end > dayStart;
        });

        // Check availability for each slot
        const availableSlots = daySlots
            .filter((slot) => isSlotAvailable(slot, dayBusyPeriods))
            .map((slot) => ({
                start: format(slot.start, "HH:mm"),
                end: format(slot.end, "HH:mm"),
            }));

        if (availableSlots.length > 0) {
            monthAvailability[dayKey] = availableSlots;
        }
    }

    availabilityData[monthKey] = monthAvailability;
    currentMonth = addMonths(currentMonth, 1);
}

// Create events data by day for the client
const eventsData = {};
let eventMonth = startOfMonth(now);
while (eventMonth <= threeMonthsLater) {
    const monthEnd = endOfMonth(eventMonth);
    const monthKey = format(eventMonth, "yyyy-MM");
    const monthEvents = {};

    const days = eachDayOfInterval({
        start: eventMonth,
        end: monthEnd,
    });

    for (const day of days) {
        const dayKey = format(day, "yyyy-MM-dd");
        const dayStart = startOfDay(day);
        const dayEnd = endOfDay(day);

        const dayEvents = relevantEvents.filter((event) => {
            return event.start < dayEnd && event.end > dayStart;
        });

        if (dayEvents.length > 0) {
            monthEvents[dayKey] = dayEvents.length;
        }
    }

    eventsData[monthKey] = monthEvents;
    eventMonth = addMonths(eventMonth, 1);
}

// Pass only the processed availability data to the client
const clientData = {
    availability: availabilityData,
    events: eventsData,
    timezone: "Europe/Berlin", // Server processes everything in CET/CEST
};
---

<Layout title="Calendar" desc="Want to know when I'm available?">
    <h1 class="text-5xl font-semibold tracking-tight surround-h1">Calendar</h1>
    <AvailabilityCalendar client:load data={clientData} />
</Layout>
